前面我和你聊到过，当我们由浅入深地认知一样新事物的时候，往往需要遵循“Why→What→How”这样的一个认知过程。



### 使用 Context API 维护全局状态
在 React 16.3 之前，Context API 由于存在种种局限性，并不被 React 官方提倡使用，开发者更多的是把它作为一个概念来探讨。而从 v 16.3.0 开始，React 对 Context API 进行了改进，新的 Context API 具备更强的可用性。

## 旧 Context API 的问题
如果组件提供的一个Context发生了变化，而中间父组件的 shouldComponentUpdate 返回 false，那么使用到该值的后代组件不会进行更新。使用了 Context 的组件则完全失控，所以基本上没有办法能够可靠的更新 Context。这篇博客文章很好地解释了为何会出现此类问题，以及你该如何规避它

*** 即便组件的 shouldComponentUpdate 返回 false，它仍然可以“穿透”组件继续向后代组件进行传播，进而确保了数据生产者和数据消费者之间数据的一致性 ***


### redux

从上图中，我们首先读出的是数据的流向规律：在 Redux 的整个工作过程中，数据流是*** 严格单向***的。这一点一定一定要背下来，面试的时候也一定一定要记得说——不管面试官问的是 Redux 的设计思想还是工作流还是别的什么概念性的知识，开局先放这句话，准没错。


### 函数组件和类组件的区别？

- 类组件和函数组件有心智层面的差异，即面向对象和函数式编程这两套不同的设计思想之间的差异

- 函数组件更符合 React 的设计理念，React 本身的定位就是一个吃进数据、吐出 UI 的函数,也就是数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点，而函数组件可以捕获到 render 内部的状态，举个例子虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的，在打破 React 生命周期对执行顺序的调控下，类组件就不会捕获到相应的 props，而是变化后的 props，而函数组件真正地把数据和渲染绑定到了一起

- 函数组件更方便逻辑的复用和整合，类组件如果体积过为庞大会有很多麻烦，比如逻辑就像是被“打散”进生命周期里了一样，而函数组件借助 Hooks 能够帮助实现业务逻辑的聚合，避免复杂的组件和冗余的代码

- 函数组件或者代码中耦合和内聚的边界，有时候真的很难把握

- Hooks 暂时还不能完全地为函数组件补齐类组件的能力：比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，官方还未补全



### 函数组件会捕获 render 内部的状态
函数组件真正地把数据和渲染绑定到了一起

像这样的生命周期函数，它的体积过于庞大，做的事情过于复杂，会给阅读和维护者带来很多麻烦。最重要的是，这些事情之间看上去毫无关联，逻辑就像是被“打散”进生命周期里了一样。比如，设置订阅和卸载订阅的逻辑，虽然它们在逻辑上是有强关联的，但是却只能被分散到不同的生命周期函数里去处理，这无论如何也不能算作是一个非常合理的设计。

而在 Hooks 的帮助下，我们完全可以把这些繁杂的操作按照逻辑上的关联拆分进不同的函数组件里：我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。


### TODO 查看评论